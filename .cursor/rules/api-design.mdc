# API è®¾è®¡è§„èŒƒ

## ğŸ›£ï¸ RESTful API è·¯ç”±è®¾è®¡

### URL å‘½åè§„èŒƒ
```python
# âœ… æ­£ç¡®çš„RESTé£æ ¼
GET    /api/v1/apps              # è·å–åº”ç”¨åˆ—è¡¨
POST   /api/v1/apps              # åˆ›å»ºåº”ç”¨
GET    /api/v1/apps/{app_id}     # è·å–å•ä¸ªåº”ç”¨
PUT    /api/v1/apps/{app_id}     # æ›´æ–°åº”ç”¨
DELETE /api/v1/apps/{app_id}     # åˆ é™¤åº”ç”¨

# åµŒå¥—èµ„æº
GET    /api/v1/apps/{app_id}/conversations        # è·å–åº”ç”¨çš„å¯¹è¯åˆ—è¡¨
POST   /api/v1/apps/{app_id}/conversations        # åˆ›å»ºå¯¹è¯
GET    /api/v1/conversations/{conversation_id}    # è·å–å¯¹è¯è¯¦æƒ…

# âŒ é¿å…çš„è®¾è®¡
GET    /api/v1/getApps           # ä¸è¦åœ¨URLä¸­ä½¿ç”¨åŠ¨è¯
POST   /api/v1/createApp         # ä½¿ç”¨HTTPæ–¹æ³•è¡¨ç¤ºåŠ¨ä½œ
GET    /api/v1/app/list          # å¤æ•°å½¢å¼è¡¨ç¤ºé›†åˆ
```

### æ§åˆ¶å™¨ç»“æ„ ([`api/controllers/`](mdc:api/controllers/))
```python
# controllers/console/app/app_controller.py
from flask import Blueprint, request, jsonify
from flask_login import login_required, current_user
from services.app_service import AppService
from libs.exception import validate_json

bp = Blueprint('app', __name__, url_prefix='/console/api/apps')

@bp.route('/', methods=['GET'])
@login_required
def list_apps():
    """
    è·å–åº”ç”¨åˆ—è¡¨
    ---
    tags:
      - åº”ç”¨ç®¡ç†
    parameters:
      - name: page
        in: query
        type: integer
        default: 1
      - name: limit
        in: query
        type: integer
        default: 20
      - name: keyword
        in: query
        type: string
    responses:
      200:
        description: åº”ç”¨åˆ—è¡¨
        schema:
          type: object
          properties:
            data:
              type: array
              items:
                $ref: '#/definitions/App'
            total:
              type: integer
    """
    # è·å–æŸ¥è¯¢å‚æ•°
    page = request.args.get('page', 1, type=int)
    limit = request.args.get('limit', 20, type=int)
    keyword = request.args.get('keyword', '')
    
    # è°ƒç”¨æœåŠ¡å±‚
    result = AppService.get_paginated_apps(
        user_id=current_user.id,
        page=page,
        limit=limit,
        keyword=keyword
    )
    
    return jsonify({
        'result': 'success',
        'data': result['items'],
        'total': result['total'],
        'page': result['page']
    })

@bp.route('/', methods=['POST'])
@login_required
@validate_json(['name', 'mode'])
def create_app():
    """
    åˆ›å»ºåº”ç”¨
    ---
    tags:
      - åº”ç”¨ç®¡ç†
    parameters:
      - name: body
        in: body
        required: true
        schema:
          type: object
          required:
            - name
            - mode
          properties:
            name:
              type: string
              minLength: 1
              maxLength: 255
            description:
              type: string
            mode:
              type: string
              enum: [chat, agent, workflow]
            icon:
              type: string
    """
    data = request.get_json()
    
    # åˆ›å»ºåº”ç”¨
    app = AppService.create_app(
        name=data['name'],
        description=data.get('description', ''),
        mode=data['mode'],
        icon=data.get('icon'),
        created_by=current_user.id
    )
    
    return jsonify({
        'result': 'success',
        'data': app.to_dict()
    }), 201

@bp.route('/<uuid:app_id>', methods=['GET'])
@login_required
def get_app(app_id):
    """è·å–åº”ç”¨è¯¦æƒ…"""
    app = AppService.get_app_by_id(app_id, current_user.id)
    
    return jsonify({
        'result': 'success',
        'data': app.to_dict()
    })

@bp.route('/<uuid:app_id>', methods=['PUT'])
@login_required
@validate_json(['name'])
def update_app(app_id):
    """æ›´æ–°åº”ç”¨"""
    data = request.get_json()
    
    app = AppService.update_app(
        app_id=app_id,
        user_id=current_user.id,
        **data
    )
    
    return jsonify({
        'result': 'success',
        'data': app.to_dict()
    })

@bp.route('/<uuid:app_id>', methods=['DELETE'])
@login_required
def delete_app(app_id):
    """åˆ é™¤åº”ç”¨"""
    AppService.delete_app(app_id, current_user.id)
    
    return jsonify({
        'result': 'success',
        'message': 'åº”ç”¨å·²åˆ é™¤'
    })
```

## ğŸ“„ å“åº”æ ¼å¼è§„èŒƒ

### æ ‡å‡†å“åº”ç»“æ„
```python
# æˆåŠŸå“åº”
{
    "result": "success",
    "data": {
        "id": "123e4567-e89b-12d3-a456-426614174000",
        "name": "æˆ‘çš„AIåŠ©æ‰‹",
        "description": "æ™ºèƒ½å®¢æœåŠ©æ‰‹",
        "mode": "chat",
        "created_at": "2024-01-01T00:00:00Z"
    }
}

# åˆ†é¡µå“åº”
{
    "result": "success",
    "data": [
        {"id": "...", "name": "åº”ç”¨1"},
        {"id": "...", "name": "åº”ç”¨2"}
    ],
    "total": 100,
    "page": 1,
    "limit": 20,
    "has_more": true
}

# é”™è¯¯å“åº”
{
    "result": "error",
    "code": "APP_NOT_FOUND",
    "message": "åº”ç”¨ä¸å­˜åœ¨",
    "details": {
        "app_id": "123e4567-e89b-12d3-a456-426614174000"
    }
}
```

### å“åº”è¾…åŠ©å‡½æ•°
```python
# libs/response.py
from flask import jsonify

def success_response(data=None, message=None, status_code=200):
    """æˆåŠŸå“åº”"""
    response_data = {"result": "success"}
    
    if data is not None:
        response_data["data"] = data
    if message:
        response_data["message"] = message
    
    return jsonify(response_data), status_code

def error_response(code, message, details=None, status_code=400):
    """é”™è¯¯å“åº”"""
    response_data = {
        "result": "error",
        "code": code,
        "message": message
    }
    
    if details:
        response_data["details"] = details
    
    return jsonify(response_data), status_code

def paginated_response(items, total, page, limit, has_more=None):
    """åˆ†é¡µå“åº”"""
    if has_more is None:
        has_more = page * limit < total
    
    return jsonify({
        "result": "success",
        "data": items,
        "total": total,
        "page": page,
        "limit": limit,
        "has_more": has_more
    })
```

## ğŸ” è®¤è¯å’Œæƒé™

### è®¤è¯è£…é¥°å™¨
```python
# libs/auth.py
from functools import wraps
from flask import request, current_app
from flask_login import current_user
from libs.exception import Unauthorized, Forbidden

def api_key_required(f):
    """APIå¯†é’¥è®¤è¯"""
    @wraps(f)
    def decorated_function(*args, **kwargs):
        api_key = request.headers.get('Authorization')
        if not api_key or not api_key.startswith('Bearer '):
            raise Unauthorized('ç¼ºå°‘APIå¯†é’¥')
        
        # éªŒè¯APIå¯†é’¥
        token = api_key[7:]  # ç§»é™¤ 'Bearer ' å‰ç¼€
        if not validate_api_key(token):
            raise Unauthorized('æ— æ•ˆçš„APIå¯†é’¥')
        
        return f(*args, **kwargs)
    return decorated_function

def require_permission(permission):
    """æƒé™æ£€æŸ¥è£…é¥°å™¨"""
    def decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            if not current_user.is_authenticated:
                raise Unauthorized('ç”¨æˆ·æœªç™»å½•')
            
            if not current_user.has_permission(permission):
                raise Forbidden(f'ç¼ºå°‘æƒé™: {permission}')
            
            return f(*args, **kwargs)
        return decorated_function
    return decorator

# ä½¿ç”¨ç¤ºä¾‹
@bp.route('/admin/users', methods=['GET'])
@login_required
@require_permission('admin.users.read')
def list_users():
    """ç®¡ç†å‘˜æŸ¥çœ‹ç”¨æˆ·åˆ—è¡¨"""
    pass
```

### èµ„æºæƒé™æ£€æŸ¥
```python
# services/app_service.py
class AppService:
    @staticmethod
    def get_app_by_id(app_id: str, user_id: str):
        """
        è·å–åº”ç”¨è¯¦æƒ…ï¼Œå¹¶æ£€æŸ¥ç”¨æˆ·æƒé™
        """
        app = App.query.filter(
            App.id == app_id,
            App.deleted_at.is_(None)
        ).first()
        
        if not app:
            raise AppNotFoundError()
        
        # æ£€æŸ¥ç”¨æˆ·æ˜¯å¦æœ‰æƒé™è®¿é—®æ­¤åº”ç”¨
        if not AppService.check_app_permission(app, user_id, 'read'):
            raise InsufficientPermissionError()
        
        return app
    
    @staticmethod
    def check_app_permission(app, user_id: str, action: str) -> bool:
        """
        æ£€æŸ¥ç”¨æˆ·å¯¹åº”ç”¨çš„æƒé™
        
        Args:
            app: åº”ç”¨å¯¹è±¡
            user_id: ç”¨æˆ·ID
            action: æ“ä½œç±»å‹ (read, write, delete)
        
        Returns:
            æ˜¯å¦æœ‰æƒé™
        """
        # åˆ›å»ºè€…æ‹¥æœ‰æ‰€æœ‰æƒé™
        if str(app.created_by) == user_id:
            return True
        
        # æ£€æŸ¥åä½œè€…æƒé™
        collaboration = AppCollaboration.query.filter(
            AppCollaboration.app_id == app.id,
            AppCollaboration.user_id == user_id
        ).first()
        
        if collaboration:
            return collaboration.has_permission(action)
        
        return False
```

## ğŸ“ è¾“å…¥éªŒè¯

### è¯·æ±‚æ•°æ®éªŒè¯
```python
# libs/validation.py
from pydantic import BaseModel, validator, Field
from typing import Optional
from enum import Enum

class AppMode(str, Enum):
    CHAT = "chat"
    AGENT = "agent" 
    WORKFLOW = "workflow"

class CreateAppRequest(BaseModel):
    """åˆ›å»ºåº”ç”¨è¯·æ±‚æ¨¡å‹"""
    name: str = Field(..., min_length=1, max_length=255, description="åº”ç”¨åç§°")
    description: Optional[str] = Field(None, max_length=2000, description="åº”ç”¨æè¿°")
    mode: AppMode = Field(..., description="åº”ç”¨æ¨¡å¼")
    icon: Optional[str] = Field(None, description="åº”ç”¨å›¾æ ‡")
    
    @validator('name')
    def validate_name(cls, v):
        if not v.strip():
            raise ValueError('åº”ç”¨åç§°ä¸èƒ½ä¸ºç©º')
        return v.strip()
    
    @validator('icon')
    def validate_icon(cls, v):
        if v and not v.startswith(('http://', 'https://', 'data:')):
            raise ValueError('å›¾æ ‡å¿…é¡»æ˜¯æœ‰æ•ˆçš„URLæˆ–Data URI')
        return v

class UpdateAppRequest(BaseModel):
    """æ›´æ–°åº”ç”¨è¯·æ±‚æ¨¡å‹"""
    name: Optional[str] = Field(None, min_length=1, max_length=255)
    description: Optional[str] = Field(None, max_length=2000)
    icon: Optional[str] = None
    
    @validator('name')
    def validate_name(cls, v):
        if v is not None and not v.strip():
            raise ValueError('åº”ç”¨åç§°ä¸èƒ½ä¸ºç©º')
        return v.strip() if v else v

# éªŒè¯è£…é¥°å™¨
def validate_request(model_class):
    """è¯·æ±‚æ•°æ®éªŒè¯è£…é¥°å™¨"""
    def decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            try:
                data = request.get_json()
                if data is None:
                    raise ValidationError('è¯·æ±‚ä½“ä¸èƒ½ä¸ºç©º')
                
                # ä½¿ç”¨PydanticéªŒè¯æ•°æ®
                validated_data = model_class(**data)
                request.validated_data = validated_data
                
                return f(*args, **kwargs)
            except ValidationError as e:
                return error_response(
                    code='VALIDATION_ERROR',
                    message='æ•°æ®éªŒè¯å¤±è´¥',
                    details=e.errors(),
                    status_code=422
                )
        return decorated_function
    return decorator

# ä½¿ç”¨ç¤ºä¾‹
@bp.route('/', methods=['POST'])
@login_required
@validate_request(CreateAppRequest)
def create_app():
    """åˆ›å»ºåº”ç”¨"""
    validated_data = request.validated_data
    
    app = AppService.create_app(
        name=validated_data.name,
        description=validated_data.description,
        mode=validated_data.mode.value,
        icon=validated_data.icon,
        created_by=current_user.id
    )
    
    return success_response(app.to_dict(), status_code=201)
```

## ğŸ”„ å¼‚æ­¥ä»»åŠ¡API

### Celeryä»»åŠ¡æ¥å£
```python
# controllers/console/app/task_controller.py
@bp.route('/<uuid:app_id>/export', methods=['POST'])
@login_required
def export_app(app_id):
    """
    å¯¼å‡ºåº”ç”¨ï¼ˆå¼‚æ­¥ä»»åŠ¡ï¼‰
    
    è¿”å›ä»»åŠ¡IDï¼Œå®¢æˆ·ç«¯å¯ä»¥é€šè¿‡ä»»åŠ¡IDæŸ¥è¯¢è¿›åº¦
    """
    # æ£€æŸ¥åº”ç”¨æƒé™
    app = AppService.get_app_by_id(app_id, current_user.id)
    
    # å¯åŠ¨å¼‚æ­¥ä»»åŠ¡
    from tasks.export_task import export_app_task
    task = export_app_task.delay(str(app_id), current_user.id)
    
    return jsonify({
        'result': 'success',
        'task_id': task.id,
        'message': 'å¯¼å‡ºä»»åŠ¡å·²å¯åŠ¨'
    })

@bp.route('/tasks/<task_id>', methods=['GET'])
@login_required
def get_task_status(task_id):
    """æŸ¥è¯¢ä»»åŠ¡çŠ¶æ€"""
    from celery.result import AsyncResult
    
    task = AsyncResult(task_id)
    
    if task.state == 'PENDING':
        response = {
            'state': task.state,
            'status': 'ä»»åŠ¡ç­‰å¾…ä¸­'
        }
    elif task.state == 'PROGRESS':
        response = {
            'state': task.state,
            'status': task.info.get('status', ''),
            'progress': task.info.get('progress', 0)
        }
    elif task.state == 'SUCCESS':
        response = {
            'state': task.state,
            'status': 'ä»»åŠ¡å®Œæˆ',
            'result': task.result
        }
    else:  # FAILURE
        response = {
            'state': task.state,
            'status': 'ä»»åŠ¡å¤±è´¥',
            'error': str(task.info)
        }
    
    return jsonify({
        'result': 'success',
        'data': response
    })
```

## ğŸš« é”™è¯¯å¤„ç†

### ç»Ÿä¸€å¼‚å¸¸å¤„ç†
```python
# libs/exception.py
class BaseHTTPException(Exception):
    """HTTPå¼‚å¸¸åŸºç±»"""
    error_code = 'UNKNOWN_ERROR'
    description = 'æœªçŸ¥é”™è¯¯'
    code = 500

class ValidationError(BaseHTTPException):
    error_code = 'VALIDATION_ERROR'
    description = 'æ•°æ®éªŒè¯å¤±è´¥'
    code = 422

class AppNotFoundError(BaseHTTPException):
    error_code = 'APP_NOT_FOUND'
    description = 'åº”ç”¨ä¸å­˜åœ¨'
    code = 404

class InsufficientPermissionError(BaseHTTPException):
    error_code = 'INSUFFICIENT_PERMISSION'
    description = 'æƒé™ä¸è¶³'
    code = 403

# å…¨å±€å¼‚å¸¸å¤„ç†å™¨
@app.errorhandler(BaseHTTPException)
def handle_http_exception(e):
    """å¤„ç†è‡ªå®šä¹‰HTTPå¼‚å¸¸"""
    return error_response(
        code=e.error_code,
        message=e.description,
        status_code=e.code
    )

@app.errorhandler(ValidationError)
def handle_validation_error(e):
    """å¤„ç†æ•°æ®éªŒè¯å¼‚å¸¸"""
    return error_response(
        code='VALIDATION_ERROR',
        message='æ•°æ®éªŒè¯å¤±è´¥',
        details=e.errors() if hasattr(e, 'errors') else None,
        status_code=422
    )

@app.errorhandler(500)
def handle_internal_error(e):
    """å¤„ç†æœåŠ¡å™¨å†…éƒ¨é”™è¯¯"""
    # è®°å½•é”™è¯¯æ—¥å¿—
    import logging
    logging.error(f"Internal server error: {str(e)}")
    
    return error_response(
        code='INTERNAL_SERVER_ERROR',
        message='æœåŠ¡å™¨å†…éƒ¨é”™è¯¯',
        status_code=500
    )
```

## ğŸ“Š APIæ–‡æ¡£

### Swaggeræ–‡æ¡£é…ç½®
```python
# extensions/ext_swagger.py
from flask_restx import Api
from flask import Blueprint

# åˆ›å»ºAPIæ–‡æ¡£è“å›¾
api_doc = Blueprint('api_doc', __name__)

api = Api(
    api_doc,
    version='1.0',
    title='Dify API',
    description='Difyå¹³å°APIæ–‡æ¡£',
    doc='/doc/',
    authorizations={
        'Bearer': {
            'type': 'apiKey',
            'in': 'header',
            'name': 'Authorization',
            'description': 'JWT Token: Bearer <token>'
        }
    }
)

# å®šä¹‰æ•°æ®æ¨¡å‹
from flask_restx import fields

app_model = api.model('App', {
    'id': fields.String(required=True, description='åº”ç”¨ID'),
    'name': fields.String(required=True, description='åº”ç”¨åç§°'),
    'description': fields.String(description='åº”ç”¨æè¿°'),
    'mode': fields.String(required=True, description='åº”ç”¨æ¨¡å¼'),
    'created_at': fields.DateTime(description='åˆ›å»ºæ—¶é—´'),
})

create_app_model = api.model('CreateApp', {
    'name': fields.String(required=True, description='åº”ç”¨åç§°'),
    'description': fields.String(description='åº”ç”¨æè¿°'),
    'mode': fields.String(required=True, description='åº”ç”¨æ¨¡å¼'),
    'icon': fields.String(description='åº”ç”¨å›¾æ ‡'),
})
```

## ğŸ“ˆ APIæ€§èƒ½ä¼˜åŒ–

### ç¼“å­˜ç­–ç•¥
```python
# libs/cache.py
from flask import request
import hashlib
import json
from extensions.ext_redis import redis_client

def cache_response(timeout=300):
    """å“åº”ç¼“å­˜è£…é¥°å™¨"""
    def decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            # ç”Ÿæˆç¼“å­˜é”®
            cache_key = generate_cache_key(request, args, kwargs)
            
            # å°è¯•ä»ç¼“å­˜è·å–
            cached_result = redis_client.get(cache_key)
            if cached_result:
                return json.loads(cached_result)
            
            # æ‰§è¡Œå‡½æ•°
            result = f(*args, **kwargs)
            
            # ç¼“å­˜ç»“æœ
            redis_client.setex(
                cache_key,
                timeout,
                json.dumps(result, default=str)
            )
            
            return result
        return decorated_function
    return decorator

def generate_cache_key(request, args, kwargs):
    """ç”Ÿæˆç¼“å­˜é”®"""
    key_data = {
        'path': request.path,
        'args': request.args.to_dict(),
        'func_args': args,
        'func_kwargs': kwargs,
        'user_id': getattr(current_user, 'id', None)
    }
    
    key_str = json.dumps(key_data, sort_keys=True)
    return f"api_cache:{hashlib.md5(key_str.encode()).hexdigest()}"
```
description: APIè®¾è®¡è§„åˆ™
globs:
alwaysApply: false
---
